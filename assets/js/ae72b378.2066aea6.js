(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{168:function(e,t,n){"use strict";n.r(t),n.d(t,"MDXContext",(function(){return u})),n.d(t,"MDXProvider",(function(){return p})),n.d(t,"mdx",(function(){return h})),n.d(t,"useMDXComponents",(function(){return m})),n.d(t,"withMDXComponents",(function(){return s}));var r=n(0),a=n.n(r);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(){return(l=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e}).apply(this,arguments)}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function d(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var u=a.a.createContext({}),s=function(e){return function(t){var n=m(t.components);return a.a.createElement(e,l({},t,{components:n}))}},m=function(e){var t=a.a.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):d(d({},t),e)),n},p=function(e){var t=m(e.components);return a.a.createElement(u.Provider,{value:t},e.children)},b={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},f=a.a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,o=c(e,["components","mdxType","originalType","parentName"]),u=m(n),s=r,p=u["".concat(l,".").concat(s)]||u[s]||b[s]||i;return n?a.a.createElement(p,d(d({ref:t},o),{},{components:n})):a.a.createElement(p,d({ref:t},o))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,l=new Array(i);l[0]=f;var o={};for(var d in t)hasOwnProperty.call(t,d)&&(o[d]=t[d]);o.originalType=e,o.mdxType="string"==typeof e?e:r,l[1]=o;for(var c=2;c<i;c++)l[c]=n[c];return a.a.createElement.apply(null,l)}return a.a.createElement.apply(null,n)}f.displayName="MDXCreateElement"},60:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return l})),n.d(t,"metadata",(function(){return o})),n.d(t,"toc",(function(){return d})),n.d(t,"default",(function(){return u}));var r=n(3),a=n(8),i=(n(0),n(168)),l={sidebar_position:4,keywords:"pallet design, intermediate, runtime"},o={unversionedId:"pallet-design/simple-crowdfund",id:"pallet-design/simple-crowdfund",isDocsHomePage:!1,title:"Simple crowdfund",description:"WIP",source:"@site/docs/02-pallet-design/simple-crowdfund.md",sourceDirName:"02-pallet-design",slug:"/pallet-design/simple-crowdfund",permalink:"/substrate-how-to-guides/docs/pallet-design/simple-crowdfund",editUrl:"https://github.com/substrate-developer-hub/substrate-how-to-guides/edit/main/how-to-substrate/docs/02-pallet-design/simple-crowdfund.md",version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4,keywords:"pallet design, intermediate, runtime"},sidebar:"tutorialSidebar",previous:{title:"Create and use a struct in storage",permalink:"/substrate-how-to-guides/docs/pallet-design/storage-value-struct"},next:{title:"Simple staking pallet",permalink:"/substrate-how-to-guides/docs/pallet-design/lockable-currency"}},d=[{value:"Goal",id:"goal",children:[]},{value:"Use cases",id:"use-cases",children:[]},{value:"Overview",id:"overview",children:[]},{value:"Steps",id:"steps",children:[{value:"1. Declaring your pallet&#39;s configuration traits",id:"1-declaring-your-pallets-configuration-traits",children:[]},{value:"2. Create a custom metadata struct",id:"2-create-a-custom-metadata-struct",children:[]},{value:"3. Declare your storage items",id:"3-declare-your-storage-items",children:[]},{value:"4. Implement the Child Trie API",id:"4-implement-the-child-trie-api",children:[]},{value:"5. Write dispatchable functions",id:"5-write-dispatchable-functions",children:[]}]},{value:"Examples",id:"examples",children:[]},{value:"Resources",id:"resources",children:[]}],c={toc:d};function u(e){var t=e.components,n=Object(a.default)(e,["components"]);return Object(i.mdx)("wrapper",Object(r.default)({},c,n,{components:t,mdxType:"MDXLayout"}),Object(i.mdx)("p",null,Object(i.mdx)("em",{parentName:"p"},"WIP")),Object(i.mdx)("p",null,Object(i.mdx)("em",{parentName:"p"},"How to get the core functionality of a crowdfunding application in a single pallet.")),Object(i.mdx)("h2",{id:"goal"},"Goal"),Object(i.mdx)("p",null,"Build a pallet that controls multiple token accounts, storing data in child storage."),Object(i.mdx)("h2",{id:"use-cases"},"Use cases"),Object(i.mdx)("p",null,"A simple on-chain crowdfunding app for participants to pool funds towards a common goal."),Object(i.mdx)("h2",{id:"overview"},"Overview"),Object(i.mdx)("p",null,"Use one trie for each active crowdfund."),Object(i.mdx)("p",null,"Any user can start a crowdfund by specifying a goal amount for the crowdfund, an end time, and a beneficiary who will\nreceive the pooled funds if the goal is reached by the end time. If the fund is not successful, it enters into a\nretirement period when contributors can reclaim their pledged funds. Finally, an unsuccessful fund can be dissolved,\nsending any remaining tokens to the user who dissolves it."),Object(i.mdx)("h2",{id:"steps"},"Steps"),Object(i.mdx)("h3",{id:"1-declaring-your-pallets-configuration-traits"},"1. Declaring your pallet's configuration traits"),Object(i.mdx)("p",null,"In addition to the ubiquitous ",Object(i.mdx)("inlineCode",{parentName:"p"},"Event")," type, this pallet requires a ",Object(i.mdx)("inlineCode",{parentName:"p"},"Currency")," trait as well as:"),Object(i.mdx)("ul",null,Object(i.mdx)("li",{parentName:"ul"},Object(i.mdx)("inlineCode",{parentName:"li"},"SubmissionDeposit")," - the amount to be held on deposit by the owner of a crowdfund"),Object(i.mdx)("li",{parentName:"ul"},Object(i.mdx)("inlineCode",{parentName:"li"},"MinContribution")," - the minimum amount that may be contributed into a crowdfund."),Object(i.mdx)("li",{parentName:"ul"},Object(i.mdx)("inlineCode",{parentName:"li"},"RetirementPeriod")," - the period of time (in blocks) after an unsuccessful crowdfund ending during which contributors are able to withdraw their funds.")),Object(i.mdx)("pre",null,Object(i.mdx)("code",{parentName:"pre",className:"language-rust"},"/// The pallet's configuration trait\npub trait Config: frame_system::Config {\n    type Event: From<Event<Self>> + Into<<Self as frame_system::Config>::Event>;\n    type Currency: ReservableCurrency<Self::AccountId>;\n    type SubmissionDeposit: Get<BalanceOf<Self>>;\n    type MinContribution: Get<BalanceOf<Self>>;\n    type RetirementPeriod: Get<Self::BlockNumber>;\n}\n")),Object(i.mdx)("h3",{id:"2-create-a-custom-metadata-struct"},"2. Create a custom metadata struct"),Object(i.mdx)("p",null,"Keep track of the constants in your pallet by creating a struct that stores metadata about each fund:"),Object(i.mdx)("pre",null,Object(i.mdx)("code",{parentName:"pre",className:"language-rust"},'#[derive(Encode, Decode, Default, PartialEq, Eq)]\n#[cfg_attr(feature = "std", derive(Debug))]\npub struct FundInfo<AccountId, Balance, BlockNumber> {\n    /// The account that will recieve the funds if the campaign is successful.\n    beneficiary: AccountId,\n    /// The amount of deposit placed.\n    deposit: Balance,\n    /// The total amount raised.\n    raised: Balance,\n    /// Block number after which funding must have succeeded.\n    end: BlockNumber,\n    /// Upper bound on `raised`.\n    goal: Balance,\n}\n')),Object(i.mdx)("h3",{id:"3-declare-your-storage-items"},"3. Declare your storage items"),Object(i.mdx)("p",null,"Create one storage item to track the number of funds and a second to map that index to ",Object(i.mdx)("inlineCode",{parentName:"p"},"FundInfo"),". This will also store data about\nwhich users have contributed and how many funds they contributed: "),Object(i.mdx)("pre",null,Object(i.mdx)("code",{parentName:"pre",className:"language-rust"},"#[pallet:storage]\n#[pallet::getter(fn funds)]\npub(super) type Funds<T: Config> as ChildTrie = StorageMap<\n        _, \n        Blake2_128Concat, \n        T::AccountId, \n        T::Balance,\n        ValueQuery\n        >;\n\n#[pallet:storgae]\n#[pallet::getter(fn fund_count)]\npub type FundCount<T> as ChildTrie = StorageValue<_, u32>;\n")),Object(i.mdx)("blockquote",null,Object(i.mdx)("p",{parentName:"blockquote"},"Note: The use of the child trie provides two advantages over using standard storage. First, it allows for removing the entirety\nof the trie is a single storage write when the fund is dispensed or dissolved. Second, it allows any contributor to prove that\nthey contributed using a Merkle Proof.")),Object(i.mdx)("h3",{id:"4-implement-the-child-trie-api"},"4. Implement the Child Trie API"),Object(i.mdx)("p",null,"Write the following helper functions in a ",Object(i.mdx)("inlineCode",{parentName:"p"},"impl<T: Config> Module<T>")," block:"),Object(i.mdx)("ul",null,Object(i.mdx)("li",{parentName:"ul"},"pub fn contribution_put(...) - Record a contribution in the associated child trie."),Object(i.mdx)("li",{parentName:"ul"},"pub fn contribution_get(...) - Lookup a contribution in the associated child trie."),Object(i.mdx)("li",{parentName:"ul"},"pub fn contribution_kill(...) - Remove a contribution from an associated child trie."),Object(i.mdx)("li",{parentName:"ul"},"pub fn crowdfund_kill(...) - Remove the entire record of contributions in the associated child trie in a single storage write.")),Object(i.mdx)("p",null,"Generate unique ChildInfo IDs:"),Object(i.mdx)("pre",null,Object(i.mdx)("code",{parentName:"pre",className:"language-rust"},'pub fn id_from_index(index: FundIndex) -> child::ChildInfo {\n    let mut buf = Vec::new();\n    buf.extend_from_slice(b"crowdfnd");\n    buf.extend_from_slice(&index.to_le_bytes()[..]);\n\n    child::ChildInfo::new_default(T::Hashing::hash(&buf[..]).as_ref())\n}\n')),Object(i.mdx)("h3",{id:"5-write-dispatchable-functions"},"5. Write dispatchable functions"),Object(i.mdx)("ul",null,Object(i.mdx)("li",{parentName:"ul"},Object(i.mdx)("p",{parentName:"li"},"fn create(...) - Create a new fund."),Object(i.mdx)("ul",{parentName:"li"},Object(i.mdx)("li",{parentName:"ul"},"use ",Object(i.mdx)("inlineCode",{parentName:"li"},"T::Currency::withdraw(...)")," to create imbalance variable."),Object(i.mdx)("li",{parentName:"ul"},"update the ",Object(i.mdx)("inlineCode",{parentName:"li"},"Funds")," storage item"),Object(i.mdx)("li",{parentName:"ul"},"deposit a ",Object(i.mdx)("inlineCode",{parentName:"li"},"Created")," event "))),Object(i.mdx)("li",{parentName:"ul"},Object(i.mdx)("p",{parentName:"li"},"fn contribute(...) - Contribute funds to an existing fund."),Object(i.mdx)("ul",{parentName:"li"},Object(i.mdx)("li",{parentName:"ul"},"perform preliminary safety checks using ",Object(i.mdx)("inlineCode",{parentName:"li"},"ensure!(...)")),Object(i.mdx)("li",{parentName:"ul"},"add the contribution to the fund"),Object(i.mdx)("li",{parentName:"ul"},"deposit a ",Object(i.mdx)("inlineCode",{parentName:"li"},"Contributed")," event"))),Object(i.mdx)("li",{parentName:"ul"},Object(i.mdx)("p",{parentName:"li"},"fn withdraw - (...) - Withdraw full balance of a contributor to a fund."),Object(i.mdx)("ul",{parentName:"li"},Object(i.mdx)("li",{parentName:"ul"},"perform preliminary safety checks using ",Object(i.mdx)("inlineCode",{parentName:"li"},"ensure!(...)")),Object(i.mdx)("li",{parentName:"ul"},"use the ",Object(i.mdx)("inlineCode",{parentName:"li"},"T::Currency::resolve_into_existing(...)")," to return funds"),Object(i.mdx)("li",{parentName:"ul"},"calculate new balances and update storage ",Object(i.mdx)("inlineCode",{parentName:"li"},"T::Currency::resolve_into_existing(...)")),Object(i.mdx)("li",{parentName:"ul"},"deposit ",Object(i.mdx)("inlineCode",{parentName:"li"},"Withdrew")," event"))),Object(i.mdx)("li",{parentName:"ul"},Object(i.mdx)("p",{parentName:"li"},"fn dissolve(...) - Dissolve an entire crowdfund after its retirement period has expired."),Object(i.mdx)("ul",{parentName:"li"},Object(i.mdx)("li",{parentName:"ul"},"perform preliminary safety checks using ",Object(i.mdx)("inlineCode",{parentName:"li"},"ensure!(...)")),Object(i.mdx)("li",{parentName:"ul"},"use ",Object(i.mdx)("inlineCode",{parentName:"li"},"T::Currency::resolve_creating(...)")," for dissolver to collect funds"),Object(i.mdx)("li",{parentName:"ul"},"deposit ",Object(i.mdx)("inlineCode",{parentName:"li"},"Dissolved")," event")))),Object(i.mdx)("ul",null,Object(i.mdx)("li",{parentName:"ul"},"fn dispense(...) - Dispense a payment to the beneficiary of a successful crowdfund.",Object(i.mdx)("ul",{parentName:"li"},Object(i.mdx)("li",{parentName:"ul"},"use ",Object(i.mdx)("inlineCode",{parentName:"li"},"T::Currency::resolve_creating(...)")," for beneficiary and caller (separately) to collect funds"),Object(i.mdx)("li",{parentName:"ul"},"remove the fund from storage using ",Object(i.mdx)("inlineCode",{parentName:"li"},"<Funds<T>>::remove(index);")," and ",Object(i.mdx)("inlineCode",{parentName:"li"},"Self::crowdfund_kill(index);")," to remove all contributors from storage in a single write")))),Object(i.mdx)("h2",{id:"examples"},"Examples"),Object(i.mdx)("ul",null,Object(i.mdx)("li",{parentName:"ul"},Object(i.mdx)("inlineCode",{parentName:"li"},"pallet_simple_crowdfund")," ")),Object(i.mdx)("h2",{id:"resources"},"Resources"),Object(i.mdx)("ul",null,Object(i.mdx)("li",{parentName:"ul"},"Currency ",Object(i.mdx)("a",{parentName:"li",href:"https://substrate.dev/rustdocs/v3.0.0/frame_support/traits/trait.Imbalance.html"},"Imbalance trait"))))}u.isMDXComponent=!0}}]);